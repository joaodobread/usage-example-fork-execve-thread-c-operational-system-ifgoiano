# Forks


Forks são `syscall` (chamadas de systema) usadas para criar um novo processo, que é chamado **processo filho** que roda concorrente ao processo pai.


Quando um processo faz o uso de `fork()`, a função retorna um inteiro. O possiveis retornos para essa função, são:

> Valores negativos: Quando um processo não pode ser criado;

> Valor igual a 0: Quando a chamada da função `fork()` é realizada dentro do processo filho;

> Outros valores são o PID (Proccess ID) do processo que foi gerado;

<br/>
<center>
  <img src="../assets/Fork_in_C.jpg">
</center>
<br/>

Quando um novo processo é gerado, os dois processos serão executados exatamente após a chamada da `fork`. Processos filhos usam o mesmo _program counter_, mesmos registradores na CPU, e abrem os mesmo arquivos que são usados no processo pai.


O número de processos gerados terão um total de _2^n_ 

``` c++
fork ();   // Line 1
fork ();   // Line 2
fork ();   // Line 3
```

```
       L1       // There will be 1 child process 
    /     \     // created by line 1.
  L2      L2    // There will be 2 child processes
 /  \    /  \   //  created by line 2
L3  L3  L3  L3  // There will be 4 child processes 
                // created by line 3
```

Use o código abaixo como exemplo:

``` c++
#include <bits/stdc++.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main()
{
  fork();
  fork();
  std::cout << "Hello World" << std::endl;
  return 0;
}
```

A Saída desse código é a seguinte:

```
Hello World
Hello World
Hello World
Hello World
```

A linha de impressão é rodada 2^n vezes, ou seja 2^2, que são o número de vezes que foi chamado a função fork.

Como os códigos rodam concorrencia, se o uso do PID for utilizado para que algum processo rode alguma tarefa mais custosa que outra. O processo filho pode ser terminado primeiro que o processo filho.

Nesse caso o processo filho que foi gerado irá ser executado e terminará primeiro que o processo que criou o mesmo.


``` c++
#include <bits/stdc++.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main()
{
  pid_t pid = fork();
  if (pid != 0)
  {
    for (auto i = 0; i < 10000000; ++i)
      ;
    std::cout << "main proccess" << std::endl;
  }
  else
  {

    std::cout << "child proccess" << std::endl;
  }
  return 0;
}
```

Saída:

```
child proccess
main proccess
```

Mas se eu inverter a condição, o processo pai pode ser encerrado primeiro que o processo filho e deixar ele rodando até a execução terminar.

``` c++
#include <bits/stdc++.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main()
{
  pid_t pid = fork();
  if (pid == 0)
  {
    for (auto i = 0; i < 1000000000; ++i)
      ;
    std::cout << "child proccess" << std::endl;
  }
  else
  {

    std::cout << "main proccess" << std::endl;
  }
  return 0;
}
```

Saída:

```
main proccess
child proccess
```
