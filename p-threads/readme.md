# Threads

## Diferença de Threads e Processos

É importante destacar que threads e processos são conceitos diferentes

> O processo é basicamente um agrupador de recursos (código e dados) e possui uma identidade

> Threads são criadas no contexto de um processo e compartilham o mesmo espaço de endereçamento

>> Threads não são independentes como os processos;

>> Embora compartilhem o mesmo espaço de endereçamento dentro de um processo, cada thread possui os mecanismos para gerenciar seu contexto de execução

>> Threads possuem seu próprio contador de programa, apontador de pilha e registradores

Foi usado do _GCC_ para compilar todos os códigos desse exemplo e para o uso da biblioteca `pthreads` é necessario passar uma flag dizendo que será utilizado threads para o compilador. A flag é `-pthread` sendo assim o uso do cli fica:

```shell
cc main.c -o main -pthread;
```


--- 

## Contexto de Threads

Threads criados ocupam a CPU igualmente o processo que as criou e também são escalonadas pelo próprio processo. 

Nesse contexto, quando uma aplicação multithread é iniciada, esses threads podem estar em alguns estados, que são:

> em execuçao
> bloqueio(aguardando)
> pronto para ser executado
> finalizado

Como pode ser visualizado na imagem abaixo:

<br>
<img src="../assets/thread-life-cycle.jpeg">
<br>

Com o intuito de padronizar a utilização de _threads_ a _IEEE_ estabeleceu o padrão **POSIX threads** [IEEE - 1003.1c](https://standards.ieee.org/standard/1003_1c-1995.html). 

Essas funções foram definidas no _header_ `"phreads.h"`. Além disso a biblioteca também define estrutura de dados e atributos para configurar os threads. De maneira geral esse atributos são passados como argumentos para as funções.

---

## Operações com Threads

### Criando uma thread

```c 
int pthread_create(pthread_t *__restrict__ __newthread, const pthread_attr_t *__restrict__ __attr, void *(*__start_routine)(void *), void *__restrict__ __arg)
```

`pthread_create` retorna um inteiro que será se foi possível de gerar a thread ou se deu algo de errado.

> __newthread: é o id da thread que irá ser gerado e precisa ser passado por referencia para a função

> __attr: é para definir padrões da thread, se o valor passado for _NULL_ a thread será criada seguindo o padrão.

> __start_routine: é a função que será executada ou a rotina a ser executada

> __arg: é o argumento que será passado adiante para a rotina a ser executada. 

Tanto o retorno quanto o argumento recebeido pela rotina precisam ser do tipo _`void *`_, mas pode ser feito um _cast_ para uso dentro da rotina.

``` c 

typedef struct user
{
  int id;
  char *name;
} User;

User *generateUser()
{
  User *u = (User *)calloc(1, sizeof(User));
  u->id = 101010;

  u->name = (char *)calloc(100, sizeof(char));
  strcpy(u->name, "Joao Victor");
  return u;
}

```
O trecho acima é somente para criar uma estruta de dados para que seja passada para a thread e que seja possível de passar mais de um valor para a thread utilizando somente um apontamento de memoria _`void *`_.


``` c
  pthread_t *thread_id;
  void *thread_res;
  int rstatus;
```
> pthread_t é o tipo de dado definido pela biblioteca pthread para identificar o id da thread criada. 
>> thread_id precisa ser um ponteiro, pois será alterado dentra da função `pthread_create`.

> thread_res é a variavel que será atribuida o retorno da rotina. Usa-se _`void *`_ para que seja possível passar qualquer tipo de variavel e fazer o _casting_ posteriormente.

> rstatus é o para certificar que a _thread_ foi criada e basicamente define se ela está pronta para uso.


``` c
rstatus = pthread_join(*thread_id, &thread_res);
```
Esse trecho é onde é feito o inicio de execução da thread e é onde a função inicial do programa espera o termino da thread para continuar.
`rstatus` é o retorno da função para verificar se não houve problemas na execução.

Para iniciar eu preciso dizer qual `thread` ira ser iniciada e onde será armazenado o valor retornado.

```c
int pthread_join(pthread_t __th, void **__thread_return)
```

A rotina definida para a `thread` que irá ser criada é:]
``` c
void *routine(void *arg)
{
  if (!arg)
  {
    printf("something goes wrong\n");
    exit(EXIT_FAILURE);
  }
  User *u = (User *)(arg);
  printf("id: %i \n", u->id);
  printf("name: %s \n", u->name);
  pthread_exit(u->name);
}
```

Quando terminado de executar a rotina que foi chamada ele precisa encerrar a `thread` passando algum valor de retorno. 

Confira abaixo o código na integra.


```c
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <string.h>

typedef struct user
{
  int id;
  char *name;
} User;

User *generateUser()
{
  User *u = (User *)calloc(1, sizeof(User));
  u->id = 101010;

  u->name = (char *)calloc(100, sizeof(char));
  strcpy(u->name, "Joao Victor");
  return u;
}

void *routine(void *arg);


int main(int argc, char *argv[])
{
  User *u = generateUser();

  pthread_t *thread_id;
  void *thread_res;
  int rstatus;

  rstatus = pthread_create(thread_id, NULL, routine, (void *)(u));

  if (rstatus != 0)
    exit(EXIT_FAILURE);

  printf("Thread criado com sucesso!\n");


  rstatus = pthread_join(*thread_id, &thread_res);

  if (rstatus != 0)
    exit(EXIT_FAILURE);


  printf("Thread finalizado! Retorno = %s\n", (char *)thread_res);

  return EXIT_SUCCESS;
}

void *routine(void *arg)
{
  if (!arg)
  {
    printf("something goes wrong\n");
    exit(EXIT_FAILURE);
  }
  User *u = (User *)(arg);
  printf("id: %i \n", u->id);
  printf("name: %s \n", u->name);
  pthread_exit(u->name);
}
```

Se for criado assim, será gerado apenas uma `thread` que é executada e será feito a espera pela função `main` até essa `thread` ser encerrada.

``` c 
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

void *routine(void *arg);

int main(int argc, char *argv[])
{
  pthread_t thread_idA;
  pthread_t thread_idB;
  void *thread_res;
  int rstatus;
  rstatus = pthread_create(&thread_idA, NULL, routine, (void *)("Thread A"));
  if (rstatus != 0)
    exit(EXIT_FAILURE);
  rstatus = pthread_create(&thread_idB, NULL, routine, (void *)("Thread B"));
  if (rstatus != 0)
    exit(EXIT_FAILURE);
  rstatus = pthread_join(thread_idA, &thread_res);
  if (rstatus != 0)
    exit(EXIT_FAILURE);
  rstatus = pthread_join(thread_idB, &thread_res);
  if (rstatus != 0)
    exit(EXIT_FAILURE);

  return 0;
}

void *routine(void *arg)
{
  int contador = 10;
  while (contador--)
    printf("%s: %i\n", (char *)arg, contador);
  pthread_exit(arg);
}
```

O código acima mostra a criação de duas `threads` que serão executadas de maneira que uma faz sua rotina, depois a outra é iniciada após o termino da primeira. O resultado disso é: 
```
Thread A criado com sucesso!
Thread B criado com sucesso!
Thread B: 9
Thread B: 8
...
Thread B: 1
Thread B: 0
Thread A: 9
Thread A: 8
...
Thread A: 1
Thread A: 0
Thread A finalizado! Retorno = Thread A
Thread B finalizado! Retorno = Thread B
```

Isso pode ser alterado utilizando a função `sched_yield` que irá interromper a execução da `thread`, sendo assim o resultado muda e as `threads` serão executadas alternadamente.

Sendo assim a função `routine` fica da seguinte forma: 
```c
void * routine(void *arg)
{
  int contador = 10;
  while(contador--)
  {
    printf("%s: %i\n", (char *)arg, contador);
    sched_yield();
  }
  pthread_exit(arg);
}
```

E o resultado fica:

```
Thread A criado com sucesso!
Thread B criado com sucesso!
Thread B: 9
Thread A: 9
Thread B: 8
Thread A: 8
...
Thread B: 1
Thread A: 1
Thread B: 0
Thread A: 0
Thread A finalizado! Retorno = Thread A
Thread B finalizado! Retorno = Thread B
```