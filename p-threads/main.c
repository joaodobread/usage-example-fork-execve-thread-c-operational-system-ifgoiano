#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <string.h>
/*Rotina que será executada*/
void *routine(void *arg);

typedef struct user
{
  int id;
  char *name;
} User;

User *generateUser()
{
  User *u = (User *)calloc(1, sizeof(User));
  u->id = 101010;

  u->name = (char *)calloc(100, sizeof(char));
  strcpy(u->name, "Joao Victor");
  return u;
}

int main(int argc, char *argv[])
{
  // This is a argument to a routine
  User *u = generateUser();

  pthread_t *thread_id;
  void *thread_res;
  int rstatus;

  // thread creation
  // thread_id -> will be setted by function
  // Null is the configuration args to create a new thread if value is null will be created using default config
  // function will be called by thread
  // arguments to be passed to function
  // return the status of creation of thread
  rstatus = pthread_create(thread_id, NULL, routine, (void *)(u));

  // if thread creation has error the code will be exited
  if (rstatus != 0)
    exit(EXIT_FAILURE);

  // if thread can be create
  printf("Thread criado com sucesso!\n");

  // join is used to say to thead start the routine
  // thread_id is the id of created thread
  // thread_res will be attached to variable in pthread_join function
  rstatus = pthread_join(*thread_id, &thread_res);

  // the status of join will be returned, if 0 an error has occurred
  if (rstatus != 0)
    exit(EXIT_FAILURE);

  // otherwise the flow continue normally
  //
  printf("Thread finalizado! Retorno = %s\n", (char *)thread_res);

  return EXIT_SUCCESS;
}

void *routine(void *arg)
{
  /*exibe o argumento recebido*/
  if (!arg)
  {
    printf("something goes wrong\n");
    exit(EXIT_FAILURE);
  }
  User *u = (User *)(arg);
  printf("id: %i \n", u->id);
  printf("name: %s \n", u->name);
  /*finaliza a função retornando o argumento que foi recebido*/
  pthread_exit(u->name);
}