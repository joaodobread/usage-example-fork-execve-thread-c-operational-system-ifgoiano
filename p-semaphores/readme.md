# Semaphores

## Introdução

Semaforos é uma variavel ou estrutura de dados abstrata que é usada para gerenciar o controle de acesso a um recurso comum e evitar problemas em programas que usam concorrencias. 

De maneira mais simplista, semaforos são variaveis que podem ser incrementadas, decrementadas ou alternada dependendo da maneira que foi programada.

Uma maneira real de pensar em semaforos é o uso de um recurso por diversos lugares. Como por exemplo leitura e escrita em um único arquivo.

<br>
<img src="../assets/semaphores.jpeg">
<br>

> Um semáforo é um inteiro mantido pelo kernel, geralmente definido com o valor inicial maior ou igual a 0
## Dependencias
Para o uso dos semaforos será utilizada da lib `semaphores.h`

## Compilação

Para compilar os códigos de exemplos será utilizado do `gcc`, mas para uso de semáforos precisa ser passado uma flag para que seja compilado de maneira correta e como estamos também utilizando de `pthreads` precisa também da flag para `threads`. Então o uso fica assim:

``` shell
gcc main.c -o main -pthread -lrt
```

> -pthread para o uso das threads

> -lrt para o uso dos semaforos

---




Para o exemplo, será definido suas variáveis globais, o semáforo em si e uma variável que será compartilhada em algumas `threads`.

```c
static long shared = 0;
static sem_t sem;
```

Para iniciar um semáforo utiliza-se da função `sem_init`:
```c
int sem_init(sem_t *__sem, int __pshared, unsigned int __value)
```
> sem_init() retorna 0 quando há sucesso; quando ocorre erros, -1 é retornado, e um `errno` é definido para indicar qual foi o erro.

>> __sem é o ponteiro para o semaforo de tipo sem_t *
>> __pshared quando 0 o semaforo será compartilhado entre processos e threads; caso contrario será compartilhado apenas com processos e precisa ser alocado em uma região de memoria compartilhada.

>> __value é o valor inicial do semaforo

Então nosso semaforo será inciado da seguinte forma:

``` c 
sem_init(&sem, 0, 1);
```

``` c
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <pthread.h>

static long shared = 0;
static sem_t sem;

enum
{
  THREADS = 4
};

#define errExit(msg)    \
  do                    \
  {                     \
    perror(msg);        \
    exit(EXIT_FAILURE); \
  } while (0)

static void *threadFunc(void *arg)
{
  long loops = *((long *)arg);

  for (long j = 0; j < loops; j++)
  {
    if (sem_wait(&sem) == -1)
      errExit("sem_wait");

    shared++;

    if (sem_post(&sem) == -1)
      errExit("sem_post");
  }

  return NULL;
}

int main(int argc, char *argv[])
{
  pthread_t t[THREADS];
  int s;
  long nloops;

  if (argc != 2)
  {
    fprintf(stderr, "Usage: %s num_loops\n", argv[0]);
    exit(EXIT_FAILURE);
  }

  nloops = strtol(argv[1], NULL, 0);

  if (sem_init(&sem, 0, 1) == -1)
    errExit("sem_init");

  for (int i = 0; i < THREADS; ++i)
  {
    s = pthread_create(&t[i], NULL, threadFunc, &nloops);
    if (s != 0)
      errExit("pthread_create");
  }

  for (int i = 0; i < THREADS; ++i)
  {
    s = pthread_join(t[i], NULL);
    if (s != 0)
      errExit("pthread_join");
  }

  printf("shared = %ld\n", shared);
  exit(EXIT_SUCCESS);
}
```

